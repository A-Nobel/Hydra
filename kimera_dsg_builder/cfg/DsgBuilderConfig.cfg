#!/usr/bin/env python
PACKAGE = "kimera_dsg_builder"

import dynamic_reconfigure.parameter_generator_catkin as dr_gen  # NOQA

gen = dr_gen.ParameterGenerator()

# Region growing params
region_growing_cluster_estimator = gen.add_group(
    "region_growing_cluster_estimator", type="tab"
)
region_growing_cluster_estimator.add(
    "normal_estimator_neighbour_size",
    dr_gen.int_t,
    0,
    "Size of neighborhood to estimate normals for region growing clustering",
    50,
    0,
    100,
)
region_growing_cluster_estimator.add(
    "number_of_neighbours", dr_gen.int_t, 0, "N", 30, 0, 100
)
region_growing_cluster_estimator.add(
    "rg_min_cluster_size",
    dr_gen.int_t,
    0,
    "Minimum size for a cluster to be accepted",
    50,
    0,
    100,
)
region_growing_cluster_estimator.add(
    "rg_max_cluster_size",
    dr_gen.int_t,
    0,
    "Maximum size for a cluster to be accepted",
    100000,
    0,
    100000,
)
region_growing_cluster_estimator.add(
    "smoothness_threshold",
    dr_gen.double_t,
    0,
    "Smoothness term for clustering",
    0.05235,
    0,
    1,
)
region_growing_cluster_estimator.add(
    "curvature_threshold",
    dr_gen.double_t,
    0,
    "Curvature term for clustering",
    1.0,
    0,
    1,
)

# Euclidean clustering params
euclidean_cluster_estimator = gen.add_group("euclidean_cluster_estimator", type="tab")
euclidean_cluster_estimator.add(
    "ec_min_cluster_size",
    dr_gen.int_t,
    0,
    "Minimum size for a cluster to be accepted",
    50,
    0,
    400,
)
euclidean_cluster_estimator.add(
    "ec_max_cluster_size",
    dr_gen.int_t,
    0,
    "Maximum size for a cluster to be accepted",
    100000,
    0,
    100000,
)
euclidean_cluster_estimator.add(
    "cluster_tolerance", dr_gen.double_t, 0, "Cluster", 0.25, 0, 1
)

# Object finder type
object_finder_enum = gen.enum(
    [
        gen.const(
            "kRegionGrowing", dr_gen.int_t, 0, "A region growing clustering algorithm"
        ),
        gen.const("kEuclidean", dr_gen.int_t, 1, "An euclidean clustering algorithm"),
    ],
    "An enum to set type of object clustering algorithm.",
)
gen.add(
    "object_finder_type",
    dr_gen.int_t,
    0,
    "Type of object finder to be used",
    1,
    0,
    1,
    edit_method=object_finder_enum,
)

# Marching cubes params
marching_cubes = gen.add_group("marching_cubes", type="tab")
marching_cubes.add(
    "iso_level",
    dr_gen.double_t,
    0,
    "Iso level to be extracted using marching cubes",
    0.0,
    -10.0,
    10.0,
)
marching_cubes.add(
    "grid_res", dr_gen.int_t, 0, "Marching cubes grid resolution", 50, 0, 100
)
marching_cubes.add(
    "extend_percentage", dr_gen.double_t, 0, "Not sure what this is", 0, 0, 1
)
marching_cubes.add(
    "off_surface_displacement",
    dr_gen.double_t,
    0,
    "Not sure what this is (only used with RBF)",
    0.01,
    0,
    1,
)

marching_cubes_enum = gen.enum(
    [
        gen.const("kHoppe", dr_gen.int_t, 0, "Hoppes marching cubes"),
        gen.const("kRBF", dr_gen.int_t, 1, "Radial Basis Function marching cubes"),
    ],
    "An enum to set type of room finder algorithm.",
)
gen.add(
    "hoppe_or_rbf",
    dr_gen.int_t,
    0,
    "Type of room finder to be used",
    1,
    0,
    1,
    edit_method=marching_cubes_enum,
)

# Outlier removal params
outlier_removal = gen.add_group("outlier_removal", type="tab")
outlier_removal.add(
    "radius_search",
    dr_gen.double_t,
    0,
    "Search radius for outlier removal [m]",
    0.11,
    0.0,
    0.5,
)
outlier_removal.add(
    "min_neighbors_in_radius",
    dr_gen.int_t,
    4,
    "Minimum number of neighbors for a point to be kept.",
    12,
    0,
    30,
)

exit(gen.generate(PACKAGE, "kimera_dsg_builder", "DsgBuilder"))
